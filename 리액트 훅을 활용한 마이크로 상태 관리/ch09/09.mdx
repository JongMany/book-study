# 사용 사례 시나리오 3: Valtio

Valtio는 Zustand나 Jotai와 다르게 변경 가능한 갱신 모델(Mutating Update Model)을 기반으로 하는 전역 상태 라이브러리임

- Zustand처럼 모듈 상태 용으로 사용됨

리액트와의 통합을 위해 Valtio는 Proxy를 사용해 변경 불가능한 스냅샷을 가져오고,
내부적으로 Proxy를 사용해 리렌더링을 최적화함. (리렌더링 제어를 위해 선택자가 필요없음)

Valtio의 자동 렌더링 최적화는 상태 사용 추적을 기반으로 함.

- 상태 사용 추적을 통해 상태의 어느 부분이 사용되는지 감지할 수 있으며, 사용한 부분이 변경될 경우에만 컴포넌트를 리렌더링되게 할 수 있음

---

### Valtio 살펴보기

Zustand처럼 모듈 상태에 사용되는 라이브러리임

```tsx
const store = create(() => ({
  count: 0,
  text: "hello",
})
```

Zustand처럼 스토어를 생성할 수 있음.  
store에는 몇 가지 속성이 존재함. (setState 등...)
setState를 사용해 상태를 변경할 수 있음.

```tsx
store.setState((prev) => ({ count: prev.count + 1 }));
```

상태 갱신을 위해 `setState`을 사용하는데 상태를 불변으로 갱신하기 위함임

<details>
  <summary>내부적으로 `setState`가 동작하는 방식</summary>

```tsx
moduleState = Object.assign({}, moduleState, {
  count: moduleState.count + 1,
});
```

이 같은 방식으로 객체를 불변으로 갱신함

</details>

Proxy를 사용하여 불변 갱신 규칙을 지키지 않도록 구현할 수는 있음.  
Proxy는 JS의 특수한 객체로 객체 연산을 감지하기 위한 핸들러를 만드는데 활용할 수 있음.

#### 불변 갱신 규칙을 지키지 않는 예시

```tsx
++moduleState.count;
```

이 코드를 동작하도록 만들기

```tsx
const proxyObject = new Proxy(
  {
    count: 0,
    text: "hello",
  },
  {
    set: (target, key, value) => {
      console.log("start setting", prop);
      target[prop] = value;
      console.log("end setting", prop);
    },
  }
);
```

두 개의 인수와 함께 new Proxy를 실행해 proxyObject를 생성함.  
Proxy의 인자

1. 객체
2. 핸들러를 담는 컬렉션 객체 (set, ...)  
   set 핸들러는 객체의 값이 갱신되려고 할 때 실행됨.

개념적으로 Proxy는 모든 변경을 감지할 수 있으므로, Zustand의 setState와 유사한 동작을 수행할 수 있음.
Valtio는 Proxy를 활용해 상태 변경을 감지하는 라이브러이자 변경 가능한 갱신 모델을 사용하는 라이브러리이다.

---

### Proxy를 활용한 변경 감지 및 불변 상태 생성하기

---

### Proxy를 활용한 리렌더링 최적화

---

### 작은 애플리케이션 만들기

---

### 접근 방식의 장단점
