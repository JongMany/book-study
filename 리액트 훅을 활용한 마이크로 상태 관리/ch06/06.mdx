# 전역 상태 라이브러리 소개

### **전역 상태 관리 문제 해결하기**

리액트는 컴포넌트를 중심으로 설계되었고, 컴포넌트는 모든 것이 재사용 가능한 것으로 여겨짐.
이전까지 만든 전역 상태는 컴포넌트 외부에 존재한다. 이는 컴포넌트에 대한 추가적인 의존성이 필요하게 된다.

전역 상태 설계 시 문제가 되는 점

1. 전역 상태를 읽는 방법  
   전역 상태는 여러 값을 가질 수 있고, 특정 컴포넌트에서는 전역 상태의 일부만 필요할 수 있다.  
   전역 상태가 바뀌면 리렌더링이 되는데, 일부만 가져오는 특정 컴포넌트도 리렌더링 발생하기에 이를 최적화해야 한다.
2. 전역 상태에 값을 넣거나 갱신 하는 방법  
   전역 상태는 중첩된 객체를 가질 수 있다. 이 중첩된 객체를 갱신할 때는 불변성을 유지해야 한다.  
   전역 상태를 직접 변경할 수 없도록 클로저를 통해 변수를 숨기는 경우도 존재함
   ```js
   const createContainer = () => {
     let state = { count: 0 };
     const getState = () => state;
     const setState = (nextState) => {
       // 상태 변경 로직
     };
     return { getState, setState };
   };
   ```

> 범용 상태 라이브러리 -> 전역 사태 뿐만 아니라 지역 상태에도 유용한 상태 관리 라이브러리

### **데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기**

전역 상태는 데이터 중심과 컴포넌트 중심이라는 2가지 유형으로 나눌 수 있음

#### 1) 데이터 중심 접근 방식

애플리케이션 설계 시, 데이터 모델은 싱글턴으로 가질 수 있으며 처리할 데이터가 이미 있을 수 있다.  
이 경우 컴포넌트를 정의하고 데이터와 컴포넌트를 연결한다. (다른 라이브러리나 서버 등 외부에서 데이터를 변경하는 것도 가능)

모듈 상태가 리액트 외부의 JS 메모리에 존재하므로 모듈 상태를 사용하는 것이 더 적합하며,  
모듈 상태는 리액트가 렌더링을 시작하기 전이나 모든 리액트 컴포넌트가 마운트 해제된 후에도 존재할 수 있다.

데이터 중심 접근 방식을 사용한 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포너트에 연결하는 API로 제공함  
모듈 상태는 상태 변수에 접근하고, 갱신하는 메서드를 가진 store 객체로 감싼다.

#### 2) 컴포넌트 중심 접근 방식

컴포넌트 중심 접근 방식은 데이터 모델이 컴포넌트에 강한 의존성을 가지고 있다.  
컴포넌트 중심 접근 방식은 컴포넌트 라이프사이클 내에서 전역 상태를 유지하는 것이며  
의존하는 컴포넌트가 언마운트되면, 전역상태도 함께 사라짐.

이를 활용하면 JS 메모리에 2개 이상의 동일한 전역 상태를 둘 수 있게 됨 (각 전역 상태는 서로 다른 컴포넌트 하위 트리에 존재하기 때문임)

데이터 중심 접근 방식을 사용하는 전역 상태 라이브러리는 팩토리 함수를 제공하며, 팩토리 함수에서는 리액트 컴포넌트에서 사용할 전역 상태를 초기화하는 함수를 생성한다.

#### 3) 두 접근 방식의 예외

꼭 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 중 하나만 선택해야 하는 것은 아님

또한, 모듈 상태는 대체로 싱글턴 패턴으로 구현되지만 하위 트리에 대해 여러 모듈 상태를 만들 수 있으며, 모듈 상태의 생명 주기를 제어할 수도 있음.

컴포넌트 상태는 보통 `useState`로 구현됨.  
그러나 변경 가능한 변수나 store가 필요한 경우 `useRef` 훅으로도 구현이 가능함.

- 변경 가능한 변수란 변경이 발생해도 리렌더링이 발생하지 않는 변수를 의미함

**모듈 상태는 데이터 중심 접근 방식에서 사용되고, 컴포넌트 상태는 주로 컴포넌트 중심 접근 방식에서 사용됨**

### **리렌더링 최적화**

리렌더링 최적화의 핵심은 컴포넌트에서 state의 어느 부분이 사용될지 지정하는 것임

state의 일부분을 지정하는 몇가지 접근 방식이 존재함.

#### 1) 선택자 함수

선택자 함수는 상태를 받아 상태의 일부를 반환하는 함수

```tsx
const Component = () => {
  const value = useSelector((state) => state.b.c);
  return <>{value}</>;
};
```

`useSelectore`는 상태가 변경될 때마다 선택자 함수의 결과를 비교하는데 사용함.

> 선택자 함수가 파생된 객체값을 반환하는 경우에는 메모이제이션을 사용해 동일한 객체를 반환하도록 해야함...

선택자 함수는 컴포넌트의 어느 부분을 사용할지 명시적으로 지정하는 방법이므로 `수동 최적화`라고 부름

#### 2) 속성 접근 감지

속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할 수 있는 상태 사용 추적(state usage tracking)이 있음
=> 자동 렌더링 최적화

```tsx
const Component = () => {
  const trackedState = useTrackedState();
  return (
    <>
      <p>{trackedState.b.c}</p>
      <p>{trackedState.e.g}</p>
    </>
  );
};
```

`useSelector`를 통해 위 코드를 최적화시키려면 복잡하다. (메모이제이션, 사용자 지정 비교함수 등을 사용해야 함)

이를 구현하기 위해서는 상태 객체에 대한 속성 접근을 확인하기 위해서 Proxy가 필요함

> `useSelector`와 `useTrackedState`의 차이점  
> state에 따른 파생값을 만들 때는 useSelector가 리렌더링에 더 최적화되었다고 볼 수 있다.

```tsx
const Component = () => {
  const isSmall = useSelector((state) => state.a < 10);
  return <>{isSmall ? 'small' : 'big'}</>;
};
>
const Component = () => {
  const isSmall = useTrackedState().a < 10;
  return <>{isSmall ? 'small' : 'big'}</>;
};
```

> useTrackedState를 쓴 경우, state.a가 변경될 때마다 리렌더링이 발생하게 된다.  
> useSelector를 쓴 경우, isSmall이 변경될 때만 리렌더링이 발생하게 된다.

#### 3) 아톰 사용

아톰: 리렌더링을 발생시키는데 사용되는 최소 상태 단위  
전역 상태를 구독해서 리렌더링을 피하는 대신 아톰을 사요앟면 좀 더 세분화해서 구독하는 것이 가능해짐

atom 함수는 state 객체에서 아톰을 생성할 수 있다.

```ts
const globalState = {
  a: atom(1),
  b: atom(2),
  c: atom(3),
};

const Component = () => {
  const a = useAtom(globalState.a);
  return <>{a}</>;
};
```

아톰이 완전히 분리되어 있다면 별도의 전역 상태를 갖는 것과 같다고 볼 수 있고, 아톰으로 파생 값을 만들 수도 있음.

```ts
const sum = globalState.a + globalState.b + globalState.c;
```

이를 위해서는 의존성을 추적해서 아톰이 갱신될 때마다 파생값을 다시 평가해야함
예시) Jotai 라이브러리

수동최적화와 자동 최적화의 중간정도로 볼 수 있다. (아톰과 파생 값 정의는 명시적이지만 의존성 추적은 자동으로 됨)
