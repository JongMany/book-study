# 되돌릴 수 있는 구조 변경

#### 선행 코드 정리의 특징

- 구조 변경은 대체로 되돌릴 수 있다는 특징이 있음.  
  예시) 도우미 함수를 추출한 다음 마음에 들지 않는다면 원래대로 되돌리는 것은 쉬움

- 동작 변경  
  소프트웨어 세계에서의 동작 변경

  - 대부분의 소프트웨어 설계 결정은 쉽게 되돌릴 수 있기에 구현 후, 코드 정리를 통해 정리하는 것임
  - 되돌릴 수 없는 설계 변경 ➡️ 서비스로 추출하기(extract as a service)은 생각해볼 필요가 있는 주제임
    - 프로토타입을 만들기 ➡️ 기능 플래그를 활용하기 (이를 통해 당분간은 가역성 있게 코드를 변경할 수 있음)
  - 설계 결정이 코드베이스에 전파되는 경우. (integer를 long타입으로 수정하는 경우 백만 개의 변경을 요구하는 경우)  
    ➡️ 이런 경우에는 이 결정이 확산될 가능성이 있는 결정인지에 대해 생각해보고, 그런 결정이 발생하면 한 번에 하나씩 정리해나가기

  현실 세계에서의 동작 변경

  - 예시) 번호가 잘못 찍힌 세금 고지서 10만건을 발송하게 되면 해결하는데 큰 비용이 들게 됨.  
    공지를 보내기 5분 전에 알게 되면 비용이 적게 들지만, 5분 후에 알게 되면 비용이 많이 들게 됨.

일반적으로 되돌릴 수 있는 결정은 되돌릴 수 없는 결정과 다르게 취급해야 함 ➡️ 신중하게 결정해야 함

괴짜들은 모든 상황을 이상적으로만 생각해서, 결코 실수하는 일 없이 더 나은 의사결정을 할 수 있다고 믿는 듯함.  
➡️ '내가 무한히 똑똑하다면'이라는 제단을 숭배하지 말고 '가역성'의 가치를 이해하자

켄트백은 '가역성'이라는 단어를 알기 훨씬 전부터 되돌릴 수 있는 일의 가치를 배우고, 결정을 되돌릴 수 있게 만드는 것의 가치를 깨달았었음.

---

켄트 백(Kent Beck)은 "가역성"의 가치를 일찍이 깨달았습니다. 그는 "내가 무한히 똑똑하다면"이라는 이상을 추구하는 대신, 실수할 가능성을 염두에 두고, 결정이 잘못되었을 때 이를 되돌릴 수 있는 능력을 중시했습니다. 이는 다음과 같은 점을 시사합니다:

실수를 줄이는 것이 아니라, 실수를 되돌릴 수 있도록 하는 것: 모든 결정을 완벽하게 할 수는 없지만, 잘못된 결정을 되돌릴 수 있도록 하는 것이 중요합니다.
가역성의 가치: 가역성이 있는 결정은 더 유연하게 대응할 수 있고, 잘못된 경우에도 쉽게 수정할 수 있습니다
